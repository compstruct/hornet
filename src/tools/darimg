#!/usr/bin/env python
# -*- mode:python; indent-tabs-mode:nil; -*-
# vim:set expandtab shiftwidth=4 filetype=python:

from __future__ import with_statement

import sys, os, optparse, re, subprocess, ConfigParser

objdump = 'objdump'
file_magic = 'DAR '
file_version = 200903190

class Err(Exception):
    pass

def w2bs(w):
    '''convert a 32-bit word into four bytes in big-endian order'''
    assert w >= 0
    assert w <= (1 << 32)
    return ''.join([chr((w >> sa) & 0xff) for sa in [24, 16, 8, 0]])

def read_section_headers(file, objdump_cmd='objdump', verbose=False):
    '''process file and section headers'''
    entry = None
    format = None
    sections = {}
    try:
        proc = subprocess.Popen([objdump_cmd, '-fh', file], stdout=subprocess.PIPE)
        format_pat = re.compile(r'^.*file\s+format\s+(\S+)\s*$')
        entry_pat = re.compile(r'^\s*start\s+address\s+0x([0-9A-Fa-f]+)\s*$')
        info_pat = re.compile(r'^\s*\d+\s+(\S+)\s+([0-9A-Fa-f]+)\s+[0-9A-Fa-f]+\s+([0-9A-Fa-f]+)\s+[0-9A-Fa-f]+\s+2\*\*\d+\s*$')
        while True:
            l = proc.stdout.next().strip()
            m = format_pat.match(l)
            if m:
                assert(format is None)
                format = m.group(1)
                continue
            m = entry_pat.match(l)
            if m:
                assert(entry is None)
                entry = int(m.group(1), 16)
            m = info_pat.match(l)
            if m:
                name = m.group(1)
                if name in sections:
                    raise Err('duplicate section #%s' % name)
                sections[name] = { 'name': name,
                                   'size': int(m.group(2), 16),
                                   'lma': int(m.group(3), 16) }
                try:
                    l = proc.stdout.next().strip()
                except StopIteration:
                    raise Err('bad section %s header objdump' % name)
                sections[name]['flags'] = l.split(', ')
    except StopIteration:
        pass
    if verbose:
        print 'file %s format %s' % (file, format)
        print '  entry point 0x%08x' % entry
        for k,v in sections.iteritems():
            print ('  section %s size %d at 0x%08x flags %s' %
                   (k, v['size'], v['lma'], ' '.join(v['flags'])))
    return file, format, entry, sections.values()

def sort_sections(all_secs, verbose=False):
    loadable = [s for s in all_secs if 'LOAD' in s['flags']]
    if len(loadable) < 1:
        raise Err('there are no loadable sections')
    ordered = sorted(loadable, lambda s, t: cmp(s['lma'], t['lma']))
    for s in ordered:
        if 'RELOC' in s['flags']:
            raise Err('relocatable sections not supported (section %s)' % s)
    for s1, s2 in zip(ordered, ordered[1:]):
        if s1['lma'] + s1['size'] > s2['lma']:
            raise Err('sections %s and %s overlap' % (s1['name'],s2['name']))
    return ordered

def write_mem_image(out, file, start, size, entry, ordered_sections,
                    objdump_cmd='objdump', verbose=False):
    def write_hexs(s):
        assert len(s) % 2 == 0
        count = len(s) / 2
        while s != '':
            out.write(chr(int(s[:2], 16)))
            s = s[2:]
        return count
    def write_zeros(out, count):
        if count > 0:
            z4k = chr(0) * 4096
            for i in range(0, count / 4096):
                out.write(z4k)
            out.write(chr(0) * (count % 4096))
        return count
    contents_pat = re.compile(r'^\s*([0-9A-Fa-f]+)\s+([0-9A-Fa-f]+)\s+([0-9A-Fa-f]+)\s+([0-9A-Fa-f]+)\s+([0-9A-Fa-f]+)\s+')
    sp = start + size - 4  # stack starts on top of memory
    if verbose:
        print ('writing image at 0x%08x size 0x%08x entry 0x%08x stack 0x%08x' %
               (start, size, entry, sp))
    out.write(w2bs(start)) # memory image start address
    out.write(w2bs(size))  # memory image size
    where = start
    for sec in ordered_sections:
        if verbose: print 'processing section:', sec['name']
        assert (sec['lma'] - where) >= 0
        where += write_zeros(out, sec['lma'] - where)
        proc = subprocess.Popen([objdump_cmd, '-j', sec['name'], '-s',
                                 file], stdout=subprocess.PIPE)
        for l in proc.stdout:
            m = contents_pat.match(l.strip())
            if m:
                addr = int(m.group(1), 16)
                assert addr >= where
                where += write_zeros(out, addr - where)
                where += write_hexs(''.join(m.groups()[1:5]))
    where += write_zeros(out, start + size - where)
    out.write(w2bs(entry)) # entry point (initial PC)
    out.write(w2bs(sp))    # initial stack pointer

def write_header(out, verbose=False):
    if verbose:
        print ('writing header: magic \"%s\" version %d' %
                (file_magic, file_version))
    out.write(file_magic)
    out.write(w2bs(file_version))

def write_pe(out, id, img, n2b_bw, b2n_bw, qmem_size,
             n2b_queues, b2n_queues, verbose=False):
    if verbose:
        print 'writing PE %d' % id
    out.write(w2bs(id))
    # node
    out.write(w2bs(qmem_size))
    # bridge
    out.write(w2bs(n2b_bw))
    out.write(w2bs(b2n_bw))
    # node->bridge connection
    out.write(w2bs(len(b2n_queues)))
    for q in b2n_queues: out.write(w2bs(q))
    out.write(w2bs(len(n2b_queues)))
    for q in n2b_queues: out.write(w2bs(q))
    # memory and CPU
    file, format, entry, all_sections = \
            read_section_headers(img, verbose=verbose)
    sections = sort_sections(all_sections, verbose=verbose)
    start = sections[0]['lma'] & 0xfffff000
    addr_past_end = sections[-1]['lma'] + sections[-1]['size']
    size = ((addr_past_end - start) & 0xfffff000) + 0x1000 + 0x4000
    write_mem_image(out, file, start, size, entry, sections, verbose=verbose)

def write_cxn(out, src, src_port, dst, dst_port, bw, queues, verbose=False):
    if verbose:
        print (('writing connection %d:%s -> %d:%s with bandwidth %d '
                'and %d queues') %
                (src, src_port, dst, dst_port, bw, len(queues)))
    assert len(src_port) == 1
    assert len(dst_port) == 1
    out.write(w2bs(src))
    out.write(w2bs(ord(src_port)))
    out.write(w2bs(dst))
    out.write(w2bs(ord(dst_port)))
    out.write(w2bs(bw))
    out.write(w2bs(len(queues)))
    for q in queues: out.write(w2bs(q))

def write_route(out, queue_routing, flow, hops, verbose=False):
    def pp_hop(hop):
        if type(hop) is tuple:
            n,q = hop
            return '%s:%s' % (n,q)
        else:
            return '%s' % hop
    if verbose:
        print 'writing route for flow %08x:' % flow
        print '    ' + ' '.join([pp_hop(h) for h in hops])
    out.write(w2bs(flow))
    out.write(w2bs(len(hops)))
    if queue_routing == 0: # table routing
        for n, q in hops:
            out.write(w2bs(n))
            out.write(w2bs(q))
    elif queue_routing == 1: # round robin
        for n in hops:
            out.write(w2bs(n))
    else:
        raise Err('bad queue routing type: %s' % queue_routing)

def write_complete_image(out, cfg, verbose=False):
    settings, pes, cxns, flows = new_system_config(cfg, verbose=verbose)
    write_header(out, verbose=verbose)
    out.write(w2bs(settings['queue routing']))
    if verbose:
        print ('writing %d PE%s...' % (len(pes), '' if len(pes) == 1 else 's'))
    out.write(w2bs(len(pes)))
    for pe_cfg in pes:
        write_pe(out=out, verbose=verbose, **pe_cfg)
    if verbose:
        print ('writing %d connection%s...' %
                (len(cxns), '' if len(cxns) == 1 else 's'))
    out.write(w2bs(settings['arbitration']))
    out.write(w2bs(len(cxns)))
    for cxn_cfg in cxns: write_cxn(out=out, verbose=verbose, **cxn_cfg)
    if verbose:
        print ('writing %d flow%s...' %
                (len(flows), '' if len(flows) == 1 else 's'))
    out.write(w2bs(len(flows)))
    for flow_id, flow_hops in flows:
        write_route(out, settings['queue routing'], flow_id, flow_hops,
                    verbose=verbose)

def new_system_config(cfg, verbose=False):
    def get_links(w, h, n):
        return (([('north', 'N', n - w, 'S')] if n / w != 0 else []) +
                ([('east', 'E', n + 1, 'W')] if n % w != w - 1 else []) +
                ([('south', 'S', n + w, 'N')] if n / w != h - 1 else []) +
                ([('west', 'W', n - 1, 'E')] if n % w != 0 else []))
    def p_nat(s, min=0):
        try: ans = int(s)
        except ValueError,e:
            try: ans = int(s,16)
            except ValueError: raise Err('not a number: %s' % s)
        if ans < min: raise Err('value %s must be >= %d' % (s, d))
        return ans
    def get_code((progs,dflt), id):
        if id not in progs and dflt is None:
            raise Err('no code for CPU %d and no default' % id)
        code = progs[id] if id in progs else dflt
        if not os.path.exists(code):
            raise Err('missing code image file: %s' % code)
        return code
    def get_qs(s): return [p_nat(n) for n in cfg.get('queues',s).split()]
    def get_bw(s): return p_nat(cfg.get('bandwidth',s), 1)
    def p_flow_nq(s):
        '''node:queue format'''
        fs = []
        try:
            for f in s.split():
                n, q = [p_nat(v) for v in f.split(':')]
                fs.append((n,q))
        except ValueError:
            raise Err('bad node:queue flows description: %s' % s)
        return fs
    def p_flow_n(s):
        '''node only format'''
        fs = []
        try:
            for f in s.split():
                n = p_nat(f)
                fs.append(n)
        except ValueError:
            raise Err('bad node-only flows description: %s' % s)
        return fs
    def check_qs(dests):
        for d1 in dests:
            qs1 = set(get_qs(d1))
            for d2 in dests:
                overlap = qs1 & set(get_qs(d2))
                if d1 != d2 and len(overlap) > 0:
                    raise Err('queues for %s and %s overlap: %s' %
                              (d1, d2, ' '.join(map(str,overlap))))
    def check_flow_nq(id, hops, links):
        # hops[0] should come from cpu
        if len(hops) < 1: raise Err('flow %s: empty flow' % id)
        first_n, first_q = hops[0]
        if first_q not in get_qs('cpu'):
            raise Err('flow %s: initial queue %02x:%02x does not exit the CPU' %
                      (id, first_n, first_q))
        last_n, last_q = hops[-1]
        if last_q not in get_qs('net'):
            raise Err(('flow %s: final queue %02x:%02x does not exit '
                       'the network') % (id, last_n, last_q))
        for (src_n, _), (dst_n, dst_q) in zip(hops, hops[1:-1]):
            if [l for l in links
                if (l['src'] == src_n and l['dst'] == dst_n
                    and dst_q in l['queues'])] == []:
                raise Err(('flow %s: queue %02x:%02x does not come from '
                           'node %02x') % (id, dst_n, dst_q, src_n))
    def check_flow_n(id, hops, links):
        # hops[0] should come from cpu
        if len(hops) < 1: raise Err('flow %s: empty flow' % id)
        for src_n, dst_n in zip(hops, hops[1:]):
            if [l for l in links
                if l['src'] == src_n and l['dst'] == dst_n] == []:
                raise Err('flow %s: node %02x cannot route to node %02x' %
                          (id, src_n, dst_n))
    try:
        try:
            arb = cfg.get('bandwidth', 'arbitration')
        except Exception, e:
            arb = None
        arbs = { None: 0, 'off': 0, 'none': 0, 'proportional': 1 }
        if arb not in arbs:
            raise Error('bad arbitration type: %s' % arbitration)
        node_routing = cfg.get('routing', 'node')
        if node_routing != 'table':
            raise Error('bad node routing type: %s' % node_routing)
        queue_routing_types = { 'table': 0, 'round-robin': 1 }
        queue_routing = cfg.get('routing', 'queue')
        if queue_routing not in queue_routing_types:
            raise Error('bad queue routing type: %s' % queue_routing)
        settings = { 'arbitration': arbs[arb],
                     'queue routing': queue_routing_types[queue_routing] }
        w = p_nat(cfg.get('geometry', 'width'))
        h = p_nat(cfg.get('geometry', 'height'))
        check_qs(cfg.options('queues'))
        progs = (dict([(p_nat(n), v) for n, v in cfg.items('code')
                       if n != 'default']),
                 cfg.get('code','default') if cfg.has_option('code','default')
                                           else None)
        node_ids = range(0, w * h)
        cpu_qs = get_qs('cpu')
        nodes = [{ 'id': id,
                   'img': get_code(progs, id),
                   'n2b_bw': get_bw('cpu'),
                   'b2n_bw': get_bw('net'),
                   'qmem_size': p_nat(cfg.get('node', 'queue size')),
                   'n2b_queues': get_qs('cpu'),
                   'b2n_queues': get_qs('net') }
                 for id in node_ids]
        links = [{ 'src': src,
                   'src_port': src_port,
                   'dst': dst,
                   'dst_port': dst_port,
                   'bw': get_bw(dir),
                   'queues': get_qs(dir) }
                 for dst in node_ids
                 for dir, dst_port, src, src_port in get_links(w, h, dst)]
        if queue_routing == 'table':
            for n, v in cfg.items('flows'):
                check_flow_nq(n, p_flow_nq(v), links)
            flows = [(p_nat(n), p_flow_nq(v)) for n, v in cfg.items('flows')]
        elif queue_routing == 'round-robin':
            for n, v in cfg.items('flows'):
                check_flow_n(n, p_flow_n(v), links)
            flows = [(p_nat(n), p_flow_n(v)) for n, v in cfg.items('flows')]
        else:
            raise Err('bad queue routing type: %s' % queue_routing)
    except ConfigParser.Error, e:
        raise Err('bad config: %s' % e)
    return settings, nodes, links, flows

def main():
    try:
        usage = '%prog CONFIG...'
        opts_p = optparse.OptionParser(usage=usage)
        opts_p.add_option('-o', '--output', dest='outfile',
                          help='write memory image to FILE', metavar='FILE')
        opts_p.add_option('-v', '--verbose', dest='verbose',
                           action='store_true', default=False,
                           help='chatter more')
        opts, args = opts_p.parse_args()
        out_file = opts.outfile if opts.outfile else 'output.img'
        cfg = ConfigParser.SafeConfigParser()
        try:
            cfg.read(args)
        except Exception, e:
            raise Err('bad config: %s' % e)
        with open(out_file, 'wb') as out:
            write_complete_image(out, cfg, verbose=opts.verbose)
    except Err, e:
        print >>sys.stderr, 'ERROR:', e
        sys.exit(1)

if __name__ == '__main__': main()

