#!/usr/bin/env python

from __future__ import with_statement

import sys, string, re, optparse

def parse_decoder(file):
    required_num_fields = 18
    line_no = 0
    fields = None
    field_def_loc = None
    decoder = {}
    with open(file, 'rU') as f:
        for l0 in f:
            line_no += 1
            l = l0.lstrip().rstrip(' \n')
            if l == '' or l[0] == '#': continue
            fs = l.split('\t')
            if len(fs) != required_num_fields:
                print >>sys.stderr, \
                      ('%s:%d: %d fields instead of %d' %
                       (file, line_no, len(fs), required_num_fields))
                sys.exit(1)
            if fs[0].strip() == '?':
                if fields is not None:
                    print >>sys.stderr, \
                          ('%s:%d: fields already defined (%s)' %
                           (file, line_no, field_def_loc))
                    sys.exit(1)
                else:
                    assert fields is None
                    assert field_def_loc is None
                    field_def_loc = '%s:%d' % (file, line_no)
                    fields = ['name']
                    for field in fs[1:]:
                        field = field.strip()
                        if field == '':
                            fields.append(None)
                        elif re.match('^\d{1,2}$', field):
                            fields.append((int(field), int(field)))
                        elif re.match('^\d{1,2}\.\.\d{1,2}$', field):
                            m = re.match('^(\d{1,2})\.\.(\d{1,2})$', field)
                            hi, lo = int(m.group(1)), int(m.group(2))
                            if hi < lo:
                                print >>sys.stderr, \
                                      ('%s:%d: inverted field %s' %
                                       (file, line_no, field))
                                sys.exit(1)
                            fields.append((hi,lo))
                        else:
                            fields.append(field)
                continue
            if fields is None:
                print >>sys.stderr, \
                      ('%s:%d: instruction appears before field codes defined' %
                       (file, line_no))
                sys.exit(1)
            if len([None for t,v in zip(fields,fs)
                         if type(t) is tuple and v.strip() != '']) == 0:
                print >>sys.stderr, ('%s:%d: unsupported instruction: %s' %
                                     (file,line_no,fs[0]))
                continue
            info = {}
            for k,v in zip(fields, fs):
                if type(k) is str: info[k] = v.strip()
            d = decoder
            for k,v in zip(fields, fs):
                if type(k) is tuple:
                    hi,lo = k
                    v = v.strip()
                    if v == '': continue
                    if len(v) != hi - lo + 1:
                        print >>sys.stderr, \
                              ('%s:%d: \'%s\' must have %d bits' %
                               (file, line_no, v, hi-lo+1))
                        sys.exit(1)
                    if k not in d: d[k] = {}
                    d2 = d[k]
                    try:
                        n = int(v, 2)
                    except:
                        print >>sys.stderr, \
                              ('%s:%d: \'%s\' must be a binary natural number' %
                               (file, line_no, v))
                        sys.exit(1)
                    if n not in d2: d2[n] = {}
                    d = d2[n]
            if None in d:
                print >>sys.stderr, \
                      ('%s:%d: %s encoding collides with %s' %
                       (file, line_no, fs[0], d[None]['name']))
                sys.exit(1)
            else:
                d[None] = info
    return decoder

def gen_hdr_prologue(f):
    print >>f, '// AUTOGENERATED, DO NOT MODIFY'
    print >>f, ''
    print >>f, '#ifndef __INSTR_ENCODING_HPP__'
    print >>f, '#define __INSTR_ENCODING_HPP__'
    print >>f, ''
    print >>f, '#include "cstdint.hpp"'
    print >>f, '#include "error.hpp"'
    print >>f, '#include "bits.hpp"'
    print >>f, '#include "instr_format.hpp"'
    print >>f, ''

def gen_impl_prologue(f):
    print >>f, '// AUTOGENERATED, DO NOT MODIFY'
    print >>f, ''
    print >>f, '#include "instr_encoding.hpp"'
    print >>f, '#define __INSTR_ENCODING_HPP__'
    print >>f, ''

def gen_hdr_epilogue(f):
    print >>f, '#endif // __INSTR_ENCODING_HPP__'

def ic_name(instr):
    return 'IC_' + string.translate(instr, string.maketrans('.','_')).upper()

def gen_enum(f, dd):
    instrs = set()
    def get_instrs(d):
        for k,d2 in d.iteritems():
            if k is None:
                instrs.add(ic_name(d2['name']))
            else:
                for v, d3 in d2.iteritems(): get_instrs(d3)
    get_instrs(dd)
    print >>f, 'typedef enum {'
    for i in sorted(instrs):
        print >>f, '    %s,' % i
    print >>f, '    NUM_INSTR_CODES'
    print >>f, '} instr_code;'
    print >>f, ''

def gen_infos_typedef(f):
    print >>f, 'class instr_code_info {'
    print >>f, 'public:'
    print >>f, '    const string name;'
    print >>f, '    instr_format format;'
    print >>f, '    const string desc;'
    print >>f, '};'
    print >>f, ''
    print >>f, 'extern const instr_code_info ic_infos[];'
    print >>f, ''

def gen_infos(f, dd):
    instrs = {}
    def get_instrs(d):
        for k,d2 in d.iteritems():
            if k is None:
                instrs[ic_name(d2['name'])] = d2
            else:
                for v, d3 in d2.iteritems(): get_instrs(d3)
    get_instrs(dd)
    def esc(field, val):
        if field == 'format':
            return 'IF_' + val
        elif field == 'name':
            return '"%s"' % val.lower()
        else:
            return '"%s"' % val
    print >>f, 'const instr_code_info ic_infos[] = {'
    infos = []
    for i in sorted(instrs.keys()):
        vs = [esc(fld, instrs[i][fld]) for fld in ['name', 'format', 'desc']]
        infos.append('    { ' + ', '.join(vs) + ' }')
    print >>f, ',\n'.join(infos)
    print >>f, '};'
    print >>f, ''

def gen_decoder(f, dd):
    def decode(d, indent):
        for k,d2 in d.iteritems():
            if k is None:
                print >>f, ' ' * indent + 'ic = ' + ic_name(d2['name']) + ';'
            else:
                print >>f, ' ' * indent + 'switch (bits(encoding, %d, %d)) {' % k
                for v, d3 in d2.iteritems():
                    print >>f, ' ' * indent + 'case 0x%02x:' % v
                    decode(d3, indent + 4)
                    print >>f, ' ' * indent + '    break;'
                print >>f, ' ' * indent + '}'
    print >>f, 'inline instr_code decode(uint32_t encoding) throw(exc_bad_instr) {'
    print >>f, '    instr_code ic = NUM_INSTR_CODES;'
    decode(dd, 4)
    print >>f, '    if (ic == NUM_INSTR_CODES) throw exc_bad_instr(encoding);'
    print >>f, '    return ic;'
    print >>f, '}'

def print_decoder(dd):
    def decode(d, pfx):
        for k,d2 in d.iteritems():
            if k is None:
                print '%s --> %s' % (' '.join(pfx), d2['name'])
            else:
                hi,lo = k
                for v, d3 in d2.iteritems():
                    decode(d3, pfx + ['%d:%d=%02xh' % (hi,lo,v)])
    decode(dd, [])

def main():
    usage = ('usage: %prog INSTR_TAB')
    opts_p = optparse.OptionParser(usage=usage)
    opts_p.add_option('', '--hpp-file', dest='hpp_file', metavar='FILE',
                      help='write .hpp contents to FILE')
    opts_p.add_option('', '--cpp-file', dest='cpp_file', metavar='FILE',
                      help='write .cpp contents to FILE')
    opts, args = opts_p.parse_args()

    if len(args) != 1:
        opts_p.error('too few / too many arguments')
    decoder = parse_decoder(args[0])

    if opts.hpp_file is not None:
        with open(opts.hpp_file, 'w') as f:
            gen_hdr_prologue(f)
            gen_infos_typedef(f)
            gen_enum(f, decoder)
            gen_decoder(f, decoder)
            gen_hdr_epilogue(f)

    if opts.cpp_file is not None:
        with open(opts.cpp_file, 'w') as f:
            gen_impl_prologue(f)
            gen_infos(f, decoder)

if __name__ == '__main__': main()

